use crate::rustc_span::Pos;
use std::collections::{HashMap, BTreeMap};
use rustc_span::source_map::SourceMap;
use aquascope::analysis::{AquascopeAnalysis,
  boundaries::PermissionsBoundary};
use rustc_hir::intravisit::Visitor;
use rustc_hir::ItemKind;
use rustc_middle::ty::TyCtxt;
use rustc_utils::{
  source_map::range::CharRange,
  mir::borrowck_facts,
};
use crate::visitor::{ExprVisitor, AccessPointUsage};
use crate::PrintAllItemsPluginArgs;
use crate::utils::RV1Helper;


  
//This is a small helper function
fn charrange_to_line(crange:CharRange,source_map:&SourceMap)->usize{
  let file = crange.filename.find_source_file(source_map).unwrap();
  let cpos = crange.end;
  let mut total_bytes = cpos.0 as u32 + file.start_pos.to_u32();
  let mut flag = true;
  while flag {
    flag = false;
    for mbc in file.multibyte_chars.iter().take(cpos.0 as usize) {
      if mbc.pos.0 <= total_bytes {
        total_bytes += mbc.bytes as u32 - 1;
        flag = true;
      }
    }
  }
  let bpos = rustc_span::BytePos(total_bytes as u32);
  let (line,_,_)=file.lookup_file_pos_with_col_display(bpos);
  line
}

// "The main function"
pub fn print_all_items(tcx: TyCtxt, _args: &PrintAllItemsPluginArgs) {

  // TESTING HELPER STUFF
  let mut testing_helper: RV1Helper = RV1Helper::new();
  let mut line_map: BTreeMap<usize, String> = BTreeMap::new();
  match testing_helper.initialize_line_map() {
    Ok(l) => {
      line_map = l;
    }
    Err(e) => {
      eprintln!("{}", e);
    }
  }

  // Generate a few things needed for later analysis. They
  // are basically things generated when compiling code.
  let mut access_point_map:HashMap<AccessPointUsage, usize> = HashMap::new();

  let mut declarations: Vec<String> = Vec::new();
  let mut analysis_result: Vec<(u64, String)> = Vec::new();
  let hir = tcx.hir().clone();
  hir
  .items()
  .filter_map(|id| match &hir.item(id).kind {
    ItemKind::Fn(fn_sig, generic, body) => {
      // println!("HEADER : {:#?}", fn_sig.header);
      // println!("GENERICS: {:#?}", generic);
      // println!("FN DECLARATION : {:#?}", fn_sig.decl);
      Some(body)
    },
    _ => {
      None
    },
  })
  .for_each(|body_id| {
    let hir_body = hir.body(*body_id);
    let def_id = tcx.hir().body_owner_def_id(*body_id);
    let bwf = borrowck_facts::get_body_with_borrowck_facts(tcx, def_id);
    let body = &bwf.body;
    let span = tcx.def_span(def_id);
  // Our analysis begins here. Things are printed out.
  // run the AquascopeAnalysis and get the result
  let result=AquascopeAnalysis::run(tcx,*body_id);
  let source_map = tcx.sess.source_map();
  match result {
    Ok(output) =>{
     let _body_range = output.body_range;
     let boundaries = output.boundaries;
     let steps = output.steps;
     // Create a hashmap from BytePos to boundaries generated by aquascope
     let mut boundary_map: HashMap<rustc_span::BytePos,PermissionsBoundary> = HashMap::new();

     for boundary in boundaries {
      let bytepos=boundary.byte_location.0 as u32;
      boundary_map.insert(rustc_span::BytePos(bytepos),boundary);
    };
    /*
     // This is to print out the permission tables in aquascope (which we currently don't actually 
     // use in the analysis but might be useful). If you want to glance at what's in the table, 
     // uncomment the println!().
     for step in steps {
      let location = step.location;
      let _line = charrange_to_line(location,source_map);
      //println!("Step on line {} from {:?} to {:?}.",line,location.start,location.end);
      let state = step.state;
      for table in state {
        let _state = table.state;
        let _from = table.from;
        let _to = table.to;
        //println!("Table from {:?}-{:?} to {:?}-{:?}.",
        //from.start,from.end,to.start,to.end);
        //for (x,diff) in state{
        // println!("{} with permission diff {:?} ",
        //  x,diff);
        //};
      };
     };
     */
     
     // The visitor will walk through the hir and analysis it, see visitor.rs.
     // use last line of the body as the current scope

     let pos = charrange_to_line(_body_range,source_map);
     let mut visitor = ExprVisitor { 
      tcx, 
      mir_body:body, 
      boundary_map,
      access_points:HashMap::new(),
      mutability_map:HashMap::new(),
      lifetime_map:HashMap::new(),
      current_scope: pos,
      pre_scope: 0,
      borrow_map:HashMap::new(),
      block_return_target:None,
      analysis_result:HashMap::new(),
      owner_names:Vec::<String>::new(),
      event_line_map: & mut line_map
    };
    visitor.visit_body(hir_body);
    visitor.print_out_of_scope();
    visitor.print_lifetimes();
    //declarations.push(visitor.print_definitions());
    declarations.extend(visitor.print_definitions());
    access_point_map.extend(visitor.access_points);
    //push_str(&visitor.print_definitions());
    let ana_result = visitor.analysis_result.clone();
    for (line, elem) in ana_result{
      let newline = line as u64;
      let elem = elem;
       //println!(" [used for debug] {}:{:?}",newline,elem);
      for el in elem{
        analysis_result.push((newline,el));
      }
    }
    // order the elemens in analysis_result
    analysis_result.sort_by(|a,b|a.1.cmp(&b.1));
    for (line, elem) in analysis_result.clone(){
      let newline = line as u64;
      let elem = elem;
      println!(" [used for debug] {}:{:?}",newline,elem);
    }
    
  }
    _ =>{println!("Analysis Error.");}
  }
});
  // Print out the variable definitions.
  //declarations.sort();
  println!("/* --- BEGIN Variable Definitions ---");
  for declaration in &declarations {
    println!("{}", declaration);
  }
  println!("--- END Variable Definitions --- */");

  // TESTING HELPER STUFF
  match testing_helper.generate_vis(&mut line_map, &declarations, &access_point_map) {
    Ok(_) => {}
    Err(e) => {
      eprintln!("{}", e);
    }
  }

}